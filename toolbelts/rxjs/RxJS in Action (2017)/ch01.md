# Chapter 1: Thinking Reactively

As more and more data is received, the amount of memory that your application consumes or requires will grow linearly or, in worst cases, exponentially; this is the classic problem of **scalability**, and trying to process is all at once will certainly cause the user interface to become unresponsive.

This quantity of data is too big to be held readily available and stored in memory for use. Instead, we must create ways to fetch it from remote locations asynchronously, resulting in another big challenge of interconnected software systems: **latency**, which can be difficult to express in code.

## Synchronous vs. Asynchronous Computing

In simple terms, the main factor that separates the runtime of synchronous and asynchronous code is latency, also known as **wait time**. The traditional approach of having applications sit idle while waiting for a database query to return, a network to respond, or a user action to complete is not acceptable, so you need to take advantage of asynchronous execution so that the application is always responsive.

### Issues with Blocking Code

Synchronous execution occurs when each block of code must wait for the previous block to complete before running. Without a doubt, this is by far the easiest way to implement code because you put the burdern on your users to wait for their processes to complete. Writing code this way is much easier to grasp, maintain, and debug. 

Unfortunately, because of JavaScript's single-threaded nature, any long-running tasks shouldn't be done synchronously. Doing so creates an awful experience for your users because it causes the entire application to sit idle, wasting precious computing cycles that could easily be executing other code. This will block further progress on any other tasks that you might want to execute, which in turn leads to artifically long load times.

Mouse movement also generates a rapid succession of very quick, fine-grained events. Waiting to process each of these synchronously will cause the entire application to become unresponsive, whether it's long wait times or handling hundreds of smaller waits quickly.

### Non-Blocking Code with Callback Functions

Using functions as callbacks has been a staple of JavaScript development for years. JavaScript, being a single-threaded language, requires such a construct in order to maintain any level of usability. 

Callback functions were created to tackle the problem of blocking for long-running operations to complete by allowing you to provide a handler function that the JavaScript runtime will invoke once the data is ready for use. In the meantime, your application can continue carrying out any other task.

Using callbacks with asynchronous (AJAX) requests creates an **inversion of control** that permits your application to continue executing the next lines of code. Inversion of control in this sense refers to the way in which certain parts of your code receive the flow of control back from the runtime system. In this case, the runtime call you (or returns control to you) via the function handler when the data is ready to be processed; hence, the term **callback**.

Asynchronous code is a good design for I/O-bound work, like fetching data from the web or a database. The reason this works is that I/O processes are typically much slower than any other type of instruction, so we allow them to run in the background because they're not dependent on processor cycles to complete.

### Understanding Time and Space

Certainly, asynchronous functions allow us to stay responsive, but they come at a price. Where synchronous programs allow us to reason directly about the state of the application, asynchronous code forces us to reason about its *future* state.

Functions with side effects can perform unreliably when run in any arbitrary order. In functional and reactive programming, you'll learn to minimize them by using **pure functions**.

So, assuming that our functions were side effect free, we still have another important issue -- *time*. The main issue is how we can guarantee that these steps run in the correct order. The proper way to achieve this is by *composing* these functions together, so that the output of one becomes the input to the next, and therefore a chain of steps is created. The traditional approach that ensures the proper sequence of steps takes place is to nest a sequence of callbacks. This suggests the presence of a **temporal dependency** or time coupling between these steps.

### Are Callbacks Out of the Picture?

The short answer is no. RxJS isn't necessary when you're dealing with simple interactions. On the other hand, a library that mixes function and reactive paradigms really begins to shine when implementing state machines of moderate-to-advanced complexity.

```js
ajax('<host1>/items', items => {
  for(let item of items) {
    ajax(`<host2>/items/${item.getId()}/info`, dataInfo => {
      ajax(`<host3>/files/${dataInfo.files}`, processFiles)
    })
  }
})

beginUIRendering()
```

If continuing this pattern, we'll beging to sink into horizontally nested calls -- our model starts to grow horizontally. This trend is informally known as **callback hell**, a design that you'll want to avoid at all costs if you want to create maintainable and easy-to-reason-about programs.

There's another hidden problem with this code. The `for...of` loop isn't aware that there's latency in those calls. In these situations, you can improve matters by creating closures around your asynchronous functions, managed by using `forEach()`.

```js
ajax('<host1>/items', items => {
  items.forEach(item => {
    ajax(`<host2>/items/${item.getId()}/info`, dataInfo => {
      ajax(`<host3>/files/${dataInfo.files}`, processFiles)
    })
  })
})
```

This is why in RxJS -- and FP in general -- all loops are virtually eliminated!

### Event Emitters

Another good use of callbacks is to implement APIs based on Node.js event emitters. **Event emitters** are a popular mechanism for asynchronous event-based architectures.

```js
const EventEmitter = require('events');

class Calculator extends EventEmitter{};

const calc = new Calculator();

calc.addListener('add', (a, b) => {
  calc.emit('result', a + b);
});

calc.addListener('subtract', (a, b) => {
  calc.emit('result', a - b);
});

calc.addListener('result', (result) => {
  console.log('Result: ' + result);
});

calc.emit('add', 2, 3);
calc.emit('subtract', 2, 3);
```

Subscribing to an event emitter is done through the `addListener()` method, which allows you to provide the callback that will be called when an event of interest is fired. Unfortunately, event emitters have all of the same problems associated with using callbacks to handle emitted data coming from multiple composed resources.

## Better Callbacks with Promises

With the help of patterns emerging from FP, an alternative available to you with ES6 is to use `Promises`. `Promises` are not part of the RxJS solution, but they work together perfectly well. JavaScript ES6 introduced `Promises` to represent any asynchronous computation that's expected to complete in the future.

With `Promises`, you can chain together a set of actions with future values to form a **continuation**. A continuation (a callback) allows the function to decide what it should do next, instead of indiscriminately waiting for a return value. The code you saw earlier is known to be *continuation-passing style* (CPS), because none of the functions are explicitly waiting for a return value. But, abusing this makes code hard to reason about.

A **`Promise`** is a data type that wraps an asynchronous or long-running operation, a future value, with the ability for you to *subscribe* to its result or its error. A `Promise` is considered to be fulfilled when its underlying operation completes, at which point the subscribers will receive the computed result. Because we can't alter the value of a `Promise` once it's been executed, it's actually an immutable type, which is a functional quality.

```js
ajax('<host1>/items')
  .then(items =>
    items.forEach(item =>
      ajax(`<host2>/data/${item.getId()}/info`)
        .then(dataInfo =>
          ajax(`<host3>/data/files/${dataInfo.files}`)
        )
        .then(processFiles)
    )
  )
```

Being a more recent addition to the language with ES6, and inspired in FP design, `Promises` are more versatile and idiomatic than callbacks. Applying these functions declaratively into `then` blocks allows you to express side effects in a pure manner.

```js
let getItems = () => ajax('<host1>/items');
let getInfo = item => ajax(`<host2>/data/${item.getId()}/info`);
let getFiles = dataInfo => ajax(`<host3>/data/files/${dataInfo.files}`);

getItems()
  .then(items => items.map(getInfo))
  .then(promises => Promise.all(promises))
  .then(infos => infos.map(getFiles))
  .then(promises => Promise.all(promises))
  .then(processFiles);
```

The use of `then()` explicitly implies that there's time involved among these calls. If any step fails, we can also have matching `catch()` blocks to handle errors and potentially continue the chain of command if necessary.

The drawback of using `Promises` is that they're unable to handle data sources that produce more than one value. Also, they lack the ability to retry from failure. The most important downside, moreover, is that because `Promises` are immutable, they can't be cancelled.

Collectively, `Promises` and event emitters solve what are essentially the same problems in slightly different ways. They have different use cases (`Promise`s for single-value returns and event emitters for multiple-value returns), mostly because of their own implementation constraints. The result is that in many scenarios, a developer must use both in order to accomplish their goal.

## The Need for a Different Paradigm

We believe that it's not a matter of just choosing a library, but choosing the right paradigm for the job. By combining functional and reactive programming paradigms, RxJS will help you address the following issues:

* Familiar control flow structures (like `for` and `while` loops) with asynchronous functions don't work well together because they're not async-aware; that is, they're oblivious of wait time or latency between iterations.
* Error-handling strategies become easily convoluted when you begin nesting `try`/`catch` blocks within each callback. Also, if you want to implement some level of retry logic at every step, this will be incredibly difficult.
* Business logic is tightly coupled within the nested callback structure you need to support. It's plain to see that the more nested your code is, the harder it is to reason about. Functions that are deeply nested become entangled with other variables and functions, which is problematic in terms of readability and complexity. It would be ideal to be able to create reusable and modular components in order to have loosely coupled business logic that can be maintained and unit-tested independently.
* You want to avoid excessive use of closures, but functions in JavaScript create a closure around the scope in which they're declared. Nesting them means that you need to be concerned about not just the state of the variables passed in as arguments, but also the state of all external variables surrounding each function declaration, causing side effects to occur. Side effects increase the cognitive load of the state of your application, making it virtually impossible to keep track of what's going  on in your programs. Throw a few loops and conditional `if-else` statements into the mix, and you'll regret the day a bug occurs that impacts this functionality.
* It's difficult to detect when events or long-running operations go rogue and need to be cancelled. Consider the case of a remote HTTP request that's taking too long to process. Is the script unresponsive or is the server just slow? It would be ideal to have an easy mechanism to cancel events cleanly after some predetermined amount of time. Implementing your own cancellation mechanism can be very challenging and error prone.
* One good quality of responsive design is to always throttle a user's interaction with any UI components, so that the system isn't unnecessarily overloaded. Manual solutions for achieving this are typically very hard to get right and involve functions that access data outside their local scope, which breaks the stability of your entire program.
* It's rare to be concerned about memory management in JavaScript applications, especially client-side code. But, as UIs become larger and richer, we can begin to see that lingering event listeners may cause memory leaks and cause the size of the browser process to grow.

The truth of the matter is that the very paradigms that help us tackle these problems are hard to express in code, which is why a tool like RxJS is necessary to redefine our approach.

You learned that `Promise`s certainly move the needle in the right direction (and RxJS integrates with `Promise`s seamlessly). But, what you really need is a solution that abstracts out the notion of latency away from your code, while allowing you to model your solutions using a linear sequence of steps through which data can flow over time.

In essence, you need to combine the ability to decouple functionality like event emitters with the fluent design pattern of `Promise`s, all into a single abstraction. Moreover, you need to work with both synchronous and asynchronous code, handle errors, discourage side effects, and scale out from one to a deluge of events.

## The Reactive Extensions for JavaScript

**Reactive Extensions for JavaScript** (RxJS) is an elegant replacement for callback or `Promise`-based libraries, using a single programming model that treats any ubiquitous source of events in the exact same manner.

The power of RxJS derives from being built on top of the pillars of functional and reactive programming, as well as a few popular design patterns such as observer and iterator that have been used successfully for years. Certainly, RxJS didn't invent these patterns, but it found ways to use them within the context of FP.

### Thinking in Streams: Data Flows and Propagation

Whether you deal with thousands of key presses, movement events, touch gestures, remote HTTP calls, or single integers, RxJS treats all of these data source in exactly the same way, which we'll refer to as **data streams**.

> **Streams.** Traditionally, the term *stream* was used in programming languages as an abstract object related to I/O operations such as reading a file, reading a socket, or requesting data from an HTTP server. In the RP world, we expand the definition of a stream to mean *any* data source that can be consumed.

Reactive programming entails a mental shift in the way you reason about your program's behavior, especially if you come from an imperative background.

```js
/** Creates a stream initialized with the value 20. */
A$ = [20];
B$ = [22];
C$ = A$.concat(B$).reduce(adder);

A$.push(100);
C$ = ?
```

Streams are containers, or wrappers of data, very similar to arrays, so we used the array literal notation `[]` to symbolize this. Also, it's common to use the `$` suffix to qualify variables that point to streams. This is known as **Finnish Notation**.

> **Array Extras.** JavaScript ES5 introduced new array methods, known as the array extras, which enable some level of native support for FP. These include `map`, `reduce`, `filter`, `some`, `every`, and others.

What happens to `C$` if the value `100` is pushed onto `A$`? In the world of streams, where there's **propagation of change**, if `A$` receives a new value (a new event), this state is pushed through any streams that it's a part of. *Reactive programming is oriented around data flows and propagation.*

### Introducing the RxJS Project

RxJS is the result of many efforts to manage the myriad of problems that manifest in asynchronous programming. This latest version is a complete overhaul of the previous version with a brand-new architecture, a laser focus on performance, and drastic simplification of the API surface. It offers several distinct advantages over other JavaScript solutions, because it provides idiomatic abstractions to treat asynchronous data similar to how you would treat any source of synchronous data, like a simple array.

> **Definition.** A stream is nothing more than a sequence of events over time.

### Everything is a Stream

The concept of a stream can be applied to any data point that holds a value; this ranges from a single integer to bytes of data received from a remote HTTP call. RxJS provides lightweight data types to subscribe to and manage streams as a whole, that can be passed around as first-class objects and combined with other streams.

```js
Stream(42)
```

At this point, this stream remains dormant and nothing actually happened, until there's a subscriber (or observer) that listens for it. This is very different from `Promise`s, which execute their operations as soon as they're created. Instead, streams are *lazy* data types, which means that they execute only after a subscriber is attached.

```js
Stream(42).subscribe(
  val => console.log(val)
)
```

> #### Observer Pattern
> 
> Behind RxJS is a fine-tuned observer design pattern. It involves an object (the subject), which maintains a list of subscribers (each an observer) that are notified of any state changes. This pattern has had many applications, especially as an integral part of the model-view-controller (MVC) architecture where the view layer is constantly listening for model changes. But the rudimentary observer pattern has its drawbacks because of memory leaks related to improper disposal of observers.
> 
> RxJS draws inspiration from this pattern for its publish-subscribe methodology targeted at asynchronous programs, but adds a few extra features out of the box, like signals that indicate when a stream has completed, lazy initialization, cancellation, resource management, and disposal.

The set of operations that occurs between the creation of the producer of the stream and the consumer is what we'll refer to as the **pipeline**. The pipeline is what allows you to transform a given input into the desired output. In essence, it's where your business logic will be executed.

So far, we've created streams from *static* data sources: numbers, strings, sequences, and arrays. But the power of RxJS extends beyond that with the ability to treat *dynamic* data sources in exactly the same way, as if *time* didn't factor into the equation.

### Abstracting the Notion of Time from Your Programs

The hardest part of asynchronous code is dealing with latency and wait time. RxJS brings this notion of continuous sequences of events over time as a first-class citizen of the language -- finally, a true event subsystem for JavaScript. In essence, this means that RxJS *abstracts over time under the same programming model regardless of source*, so that you can transform your data as if your code was completely linear and synchronous.

### Components of an Rx Stream

The RxJS stream is made up of several basic components, each with specific tasks and lifetimes with respect to the overall stream.

* Producers
* Consumers
* Data pipeline
* Time

#### Producers

Producers are the sources of your data. A stream must always have a producer of data, which will be the starting point for any logic that you'll perform in RxJS. In practice, a producer is created from something that generates events independently. The observer pattern defines producers as the **subject**; in RxJS, we call them **observables**, as in something that's *able to be observed*.

Observables are in charge of pushing notifications, so we refer to this behaviors as *fire-and-forget*, which means that we'll never expect the producer to be involved in the *processing* of events, only the emission of them.

> **TC-39 Observable Spec.** The use of observables has proven to be so successful from the previous version of the library (RxJS 4) that a proposal has been made to include it in the next major release of JavaScript. Fortunately, RxJS 5 follows this proposal closely to remain completely compatible.

#### Consumers

To balance the producer half of the equation, you must also have a consumer to accept events from the producer and process them in some specific way. When the consumer begins listening to the producer for events to consume, you now have a stream, and it's at this point that the stream begins to push events; we'll refer to a consumer as an **observer**.

Streams travel only from the producer to the consumer, not the other way around. This means that part of understanding how to think in streams will mean understanding how to think about parts of an application as upstream or downstream to determine the direction in which the data will flow. With respect to RxJS, a stream will always flow from an upstream observable to a downstream observer, and both components are loosely coupled, which increases the modularity of your application.

At a fundamental level, a stream will only ever require the producer and the consumer. Once the latter is able to begin receiving events from the former, you have effectively created a stream.

#### Data Pipeline

One advantage of RxJS is that you can manipulate or edit data as it passes from the producer to the consumer. This is where the list of methods (known as observable operators) comes into play. Manipulating data en route means that you can adapt the output of the producer to match the expectations of the consumer. Doing so promotes a **separation of concerns** between the two entities, and it's a big win for the modularity of your code. This design principle is typically extremely hard to accomplish in large-scale JavaScript applications, but RxJS facilitiates this model of design.

#### Time

For everything RxJS, there's always an underlying concept of time, which you can use to manipulate streams. For now, you need only to understand that time doesn't have to always run at normal speed, and you can build streams that run slower or faster depending on your requirements.

## Reactive and Other Programming Paradigms

In practice, you can use OOP to model your domain, and use a powerful combination of reactive and FP (a combination known as functional reactive programming) to drive your behavior and events. When it comes to managing events, you'll soon begin to see an important theme in code involving Rx. Unlike in OOP, where state or data is *held* in variables or collections, state in RP is *transient*, which means that data never remains stored by actually flows through the streams that are being subscribed to, which makes event handling easy to reason about and test.

With RxJS it becomes easy to manage multiple streams of data, filtering and transforming them at will. By creating operations that can be chained together, you can also fluently create pipelines of logic that sound very much like spoken sentences.