# Chapter 3: Higher Order Functions

JavaScript as a language treats functions as data. This is a very powerful concept that allows us to pass functions in place of data. A function that takes another function as its argument is called a **higher order function**.

## Understanding Data

In a nutshell, JavaScript as a language supports the following data types:

* Numbers
* Strings
* Booleans
* Objects
* Functions
* `null`
* `undefined`

## Abstraction and Higher Order Functions

Generally speaking, higher order functions are usually written to abstract common problems. In other words, higher order functions are nothing but defining **abstractions**.

### Abstraction Definitions

Wikipedia helps us by providing this definition of abstraction:

> In software engineering and computer science, abstraction is a technique for managing complexity of computer systems. It works by establishing a level of complexity on which a person interacts with the system, suppressing the more complex details below the current level. The programmer works with an idealized interface (usually well defined) and can add additional levels of functionality that would otherwise be too complex to handle.

It also includes the following text, which is what we are interested in:

> For example, a programmer writing code that involves numerical operations may not be interested in the way numbers are represented in the underlying hardware (e.g. whether they're 16-bit or 32-bit integers), and where those details have been suppressed, it can be said that they were *abstracted away*, leaving simply numbers with which the programmer can work.

Abstraction allows us to work on the desired goal without worrying about the underlying system concepts.

### Abstraction via Higher Order Functions

```js
const forEach = (array, fn) => {
  for(let i = 0; array.length; i++) {
    fn(array[i])
  }
}
```

```js
const forEachObject = (obj, fn) => {
  for (var property in obj) {
    if (obj.hasOwnProperty(property)) {
      fn(property, obj[property])
    }
  }
}
```

An important point to note is that both `forEach` and `forEachObject` functions are higher order functions, which allow the developer to work on a task (by passing the corresponding function), abstracting away the traversing part.

```js
const unless = (predicate, fn) => {
  if(!predicate) {
    fn()
  }
}
```

```js
const times = (times, fn) => {
  for(var i = 0; i < times; i++) {
    fn(i)
  }
}
```

## Higher Order Functions in the Real World

### `every` Function

The `every` function takes two arguments: an array and a function. It checks if all the elements of the array are evaluated to `true` by the passed function.

```js
const every = (arr, fn) => {
  let result = true

  for(const value of arr) {
    result = result && fn(arr[i])
  }

  return result
}
```

### `some` Function

The `some` function returns `true` if either one of the elements in the array returns `true` for the passed function.

```js
const some = (arr, fn) => {
  let result = false

  for(const value of arr) {
    result = result || fn(value)
  }

  return result
}
```

### `sort` Function

The `sort` is a built-in function that is available in the `Array` prototype of JavaScript.

```js
arr.sort([compareFunction])
```

The `compareFunction` should implement the logic shown below.

```js
function compare(a, b) {
  if(/** a is less than b by some ordering criterion */) {
    return -1;
  }

  if(/** a is greater than b by the ordering criterion */) {
    return 1;
  }

  /** a must be equal to b */
  return 0;
}
```

```js
const sortBy = (property) => {
  return (a, b) => {
    var result = 
      (a[property] < b[property]) ? -1 
      : (a[property] > b[property]) ? 1 
      : 0;
    return result;
  }
}

people.sort(sortBy('firstname'));
people.sort(sortBy('lastname'));
```