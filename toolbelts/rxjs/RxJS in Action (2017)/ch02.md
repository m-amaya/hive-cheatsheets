# Chapter 2: Reacting with RxJS

In the object-oriented (OO) approach, classes are the main unit of work. In reactive programming in general, the fundamental unit of work is the stream.

## Functional Programming as the Pillar of Reactive Programming

The abstractions that support RP are built on top of FP, so FP is the foundation for RP. 

> ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.

The RP paradigm builds and extends from FP. Also, it leverages commonly known design patterns such as iterator and observer.

### Functional Programming

**Functional programming** is a software paradigm that emphasizes the use of functions to create programs that are declarative, immutable, and side-effect free.

RxJS borrows numerous principles from FP, particularly **function chaining**, **lazy evaluation**, and the notion of using an abstract data type to orchestrate data flows. These are some of the design decisions that drive the development of RxJS's stream programming via the `Observable` data type.

Functional programs have the following characteristics:

* **Declarative.** Functional code has a peculiar style, which takes advantage of JavaScript's higher-order functions to apply specialized business logic. Function chains (also known as **pipelines**) describe data transformation steps in an idiomatic manner.
* **Immutable.** An immutable program is one that never changes or modifies data after it's been created or after its variables have been declared. Functional programs treat data as immutable, constant values. A good practice that you'll see us use throughout this book is to qualify all of our variables with `const` to create nicely block-scoped immutable variables that can't be reassigned.
* **Side-Effect Free.** Functions with side effects depend on data residing outside its own local scope. A function's scope is made up of its arguments and any local variables declared within. Interacting with anything outside this is considered a side effect and should be avoided or, at the very least, isolated.

In general, mutations and side effects make functions unreliable and unpredictable. That is to say, if a function alters the contents of an object inadvertently, it will compromise other functions that expect this object to keep its original state. The OO solution to this is to encapsulate state and protect it from direct access from other components of the system. In contrast, FP deals with state by eliminating it, so that your functions can confidently rely on it to run.

Shared variables, especially in the global scope, add to the cognitive load of reasoning about your code because these variables demand that you keep track of them as you trace through it. Another way you can think of global data is as a hidden parameter within all your functions. So the more global the state you have to maintain, the harder it is for you to maintain your code.

Matters get worse if you have concurrent asynchronous processes where data structures are shared and used in different components. Because latency is unpredictable, you'd need to either nest your function calls or use some other robust synchronization mechanism to ensure they execute and mutate this state in the right order; otherwise, you'll experience random and hard-to-troubleshoot bugs.

Fortunately, JavaScript is single-threaded, so you don't need to worry about shared state running through different threads. But as JavaScript developers, we deal quite often with concurrent code when either working with web workers or making simultaneous HTTP calls. Working with data immutably, using FP, and the help of an asynchronous library like RxJS can amke these timing issues disappear -- immutable variables are protected against time.

Even though JavaScript isn't a pure functional language, with a bit of discipline and the help of the proper libraries, you can use it completely functionally.

Aside from using `const` to safeguard the variable's reference, JavaScript also has support for a versatile array data structure with methods such as `map`, `reduce`, `filter`, and others. These are known as higher-order or first-class functions, and they're one of the most important functional qualities in the language, allowing you to express JavaScript programs in an idiomatic way. A higher-order function is defined as once that can accept as argument as well as return other functions; they're used extensively with RxJS, as with any functional data type.

One of the main themes in FP that you'll use as well in RP is *programming without loops*.

Side-effect free functions are also known as *pure*, because they're predictable when you're working on collections of objects or streams. You should always strive for purity whenever possible because it makes your programs easy to test and reason about.

> JavaScript's `Array` object has a special place in functional programming because it behaves as an extremely powerful data type called a **functor**. In a simple sense, functors are containers that can wrap data and expose a mapping method that allows you to immutably apply transformations on this data, as shown by the `Array.map()` method. RxJS streams follow this same functor-like design.

### The Iterator Pattern
## Stream's Data-Driven Approach
## Wrapping Data Sources with `Rx.Observable`
### Identifying Different Sources of Data
### Creating RxJS Observables
### When and Where to Use RxJS
### To Push or Not To Push
## Consuming Data with Observers
### The Observer API
### Creating Bare Observables
### Observable Modules