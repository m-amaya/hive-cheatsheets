# Chapter 1: Functional Programming in Simple Terms

## What is Functional Programming? Why Does it Matter?

A function in mathematics is written like this:

```
f(X) = Y
```

This means: "A function `f`, which takes `X` as its argument, and returns the output `Y`.".

There are key takeaways in the definition:

* A function must always take an argument.
* A function must always return a value.
* A function should act only on its receiving arguments (i.e. `X`), not the outside world.
* For a given `X`, there will be only one `Y`.

Functional programming techniques are heavily based on mathematical funtions and their ideas.

Imagine we have to write a function that does tax calculations.

```js
var percentValue = 5;
var calculateTax = (value) => {
  return value/100 * (100 + percentValue);
}
```

One of the key points of our mathematical function term is that the function logic shouldn't depend on the outside world. Thus, this function we have created can't be called a real function in a mathematical sense. Let's fix that.

```js
var calculateTax = (value, percentValue) => {
  return value/100 * (100 + percentValue);
}
```

Now our `calculateTax` function can be called as a real function. What have we gained, though? Removing global variable access inside a function makes it easy for testing.

**Functional programming** is a paradigm in which we will be creating functions that are going to work out their logic by depending only on their input. This ensures that a function, when called multiple times, is going to return the same result. The function also won't change any data in the outside world, leading to a cachable and testable code base.

### Functions vs. Methods in JavaScript

A **function** is a piece of code that can be called by its name. It can be used to pass arguments that it can operate on and return values optionally.

A **method** is a piece of code that must be called by its name that is associated with an object.

```js
/** A Simple Function */
var simple = (a) => { return a; };
simple(5);
```

```js
/** A Simple Method */
var obj = ( simple: (a) => { return a; } );
obj.simple(5);
```

## Referential Transparency

With our definition of function, we have made a statement that all functions return the same value for the same input. This property of a function is called a **referential transparency**.

```js
var identity = (i) => { return i; };
```

Imagine this function is used between other function calls like this:

```js
sum(4,5) + identity(1)
```

With our referential transparency definition, we can conver that statement into this:

```js
sum(4,5) + 1
```

This process is called a **substitution model**. This leads to **parallel** code and **caching**.

## Imperative, Declarative, Abstraction

Functional programming is also about being **declarative** and writing **abstracted** code.

Suppose you have a list or array and want to iterate through the array and print it to the console.

```js
/** The Imperative Approach */
var array = [1,2,3];
for(i = 0; i < array.length; i++) {
  console.log(array[i]);
}
```

**Imperative programming** is all about telling the compiler how to do things. In **declarative programming**, however, we are going to tell the compiler what to do, rather than how. The "how" parts are abstracted into common functions. These functions are called **higher order functions**.

```js
/** The Declarative Approach */
var array = [1,2,3];
array.forEach((element) => console.log(element));
```

Functional programming is about creating functions in an abstracted way that can be reused by other parts of the code.

## Functional Programming Benefits

Most of the benefits of functional programming come from writing pure functions.

## Pure Functions

**Pure functions** are functions that return the same output for the given input. They obey referential transparency.

```js
var double = (value) => value * 2;
```

### Pure Functions Lead to Testable Code

Functions that are not pure have side effects, making them difficult to test. Apart from testing, these side effects will make the system behavior very hard to predict in the case of debugging.

Pure functions also shouldn't mutate any external environment variables.

### Reasonable Code

Code bases with pure functions are easy to read, understand, and test.

### Parallel Code

Pure functions allow us to run the code in parallel. As a pure function is not going to change any of its environments, this means we do not need to worry about *synchronizing* at all.

### Cachable

Because pure functions always return the same output for a given input, we can cache the function outputs.

### Pipelines and Composable

Pure functions should be designed in such a way that they should do only one thing. Doing only one thing and doing it perfectly is a UNIX philosophy. We can **compose** or **pipeline** to do complex tasks.

Composing is not only unique to UNIX/LINUX command lines; it is the heart of the functional programming paradigm. We call this **functional composition**.